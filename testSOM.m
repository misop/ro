function testSOM(database, selected_column, pocet_validacii, redukcia)
% Solve a Clustering Problem with a Self-Organizing Map
% Script generated by NCTOOL
% Created Mon Apr 22 10:12:12 CEST 2013


[d_riadky, d_stlpce] = size(database);
% pre kazdu dimenziu mame cislo -> vysledna ROC krivka
ROCs = zeros((d_stlpce-1), 1);
for pocet_dimenzii = 1:(d_stlpce-1)
    idx = 1;
    pocet_casti = 5;
    result = zeros(pocet_validacii, 1);
    display(pocet_dimenzii);
    for validacia = 1:pocet_validacii
        display(validacia);
        % rozdeli databazu na dany pocet casti
        indices = crossvalind('Kfold', database(:,selected_column), pocet_casti);
        % priradi patricne indexy pre dane casti, pricom
        % pocet_casti - 1 = trenovacia mnozina
        % 1 - testovacia mnozina
        mI1 = indices ~= idx;
        mI2 = indices == idx;
        % priradi databazu pre dane indexy
        training = database(mI1, :);
        testing = database(mI2, :);

        % vyselektne ten stlpec ktory testujeme
        [train_column, train_set] = takeColumn(training, selected_column);
        [test_column, test_set] = takeColumn(testing, selected_column);

        % zredukuje pocet dimenzii
        if(pocet_dimenzii < (d_stlpce-1))
            if(redukcia == 0)
                train_set = compute_mapping(train_set, 'PCA', pocet_dimenzii);
                test_set = compute_mapping(test_set, 'PCA', pocet_dimenzii);
            elseif(redukcia == 1)
                train_set = compute_mapping(train_set, 'FA', pocet_dimenzii);
                test_set = compute_mapping(test_set, 'FA', pocet_dimenzii);
            elseif(redukcia == 2)
                 train_set = fastica(train_set', 'numOfIC', pocet_dimenzii, 'stabilization', 'on', 'maxNumIterations', 5000)';
                 test_set = fastica(test_set', 'numOfIC', pocet_dimenzii, 'stabilization', 'on', 'maxNumIterations', 5000)';
            end;
        end;
        
        % samotny SOM algoritmus
        % ----------------------
        % --------START---------
        % ----------------------
       
        %sem das trenovaciu mnozinu bez stlpika co sa ma zistovat
        inputs = train_set';
        %sem das testovaciu mnozinu bez stlpika co sa ma zistovat
        test = test_set';
        %sem das stlpik testovacej mnoziny co sa ma testovat
        c1 = train_column;
        c2 = test_column;
        %kolko roznych hodnot mozes mat
        k = max(test_column) + 1;

        % Create a Self-Organizing Map
        dimension1 = 10;
        dimension2 = 10;
        net = selforgmap([dimension1 dimension2]);

        % Train the Network
        [net,tr] = train(net,inputs);

        % Test the Network
        %outputs = net(inputs);
        %suma = sum(outputs');

        % vyber udajov s hodnotou 1(jedle)
        % treba pridat pomer
        % nasobit cisla pomerom

        %sums su pre kazdy druh co ti moze vyjst kolko ich urcil do ktorej casti
        %mapy
        sums = zeros(k, dimension1*dimension2);
        for i = 1:k
            idx = (c2(:,1)==i);
            testT = test(:, idx);
            out = net(testT);
            %figure, plotsomhits(net,mushsT')
            sums(i, :) = sum(out');
        end


        out = net(test);
        % out = out';
        [m,n] = size(test_set);
        %correct je boolean matica tych co urcil spravne
        correct = [];
        outs = [];
        for i = 1:m
            idx = (out(:,i)==1);
            [maxim, ind] = max(sums(:, idx));
            correct = [correct (ind == c2(i))];
            outs = [outs ind];
        end;
        result(validacia) = (sum(correct)/m) * 100;

        %outs = sim(net, test);
        %confusion matica celkom fajn
        %[confusion, order] = confusionmat(outs, c2');

        % ---------------------------
        % -----------END-------------
        % ---------------------------
        
        % updatni idx, nech kazdym cyklom zvolim inu cast na testovanie
        idx = idx + 1;
        if(idx > pocet_casti)
            idx = pocet_casti;
        end;
    end;
    % vloz hodnoty do nasho pola, ktore potom vykreslime
    % malo by byt v percentach
    ROCs(pocet_dimenzii) = mean(result);
end;

x = 1:(d_stlpce-1);
y = ROCs;

figure;
plot(x,y);
xlim([1 (d_stlpce-1)]);
ylim([0 100]);
